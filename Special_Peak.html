
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>tatch_exercise</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-08-27"><meta name="DC.source" content="tatch_exercise.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Import the relevant signal data</a></li><li><a href="#2">Detrend the signal to remove the linear bias</a></li><li><a href="#3">Grab the peak values and positions of the peaks</a></li><li><a href="#4">Prepare data structures prior to valid peak detection routine</a></li><li><a href="#5">Begin valid peak routine</a></li><li><a href="#6">Determine the special peak</a></li><li><a href="#7">Plotting signals</a></li></ul></div><h2 id="1">Import the relevant signal data</h2><p>I converted the csv to a text file prior to using it because it was easier to import.</p><pre class="codeinput">signal_data_file = <span class="string">'Signal.txt'</span>;                       <span class="comment">% Grab the file name</span>
delimiter = <span class="string">','</span>;                                       <span class="comment">% Set delimiter as a comma since data is seperated via commas</span>
signal_data = importdata(signal_data_file,delimiter);  <span class="comment">% Import the data</span>
time = 0:0.1:180.0;                                    <span class="comment">% Create a time vector based on the sampling rate. (10Hz = 0.1s spanning 1801 points)</span>

<span class="comment">% Initialize two empty arrays which will dynamically grow as we find peaks</span>
peaks = [];             <span class="comment">% Will hold the peak values</span>
timestamps = [];        <span class="comment">% Will hold the time stamps at which the peaks are found</span>

signal_mean_value = 0.6833; <span class="comment">% The expected true signal mean value</span>
</pre><h2 id="2">Detrend the signal to remove the linear bias</h2><pre class="codeinput"><span class="comment">% We know that y(t) = s(t) + at. We also know that sum(s(t)) / length(t) = 0.6833</span>
<span class="comment">% We can use this information to derive the linear bias 'a':</span>
<span class="comment">% sum( y(t) - s(t) ) / length(time)  =  0.6833</span>
<span class="comment">% =&gt; sum(y(t)) - sum(s(t)) = 0.6833 * length(time)</span>
<span class="comment">% =&gt; sum(s(t)) = sum(y(t)) - ( 0.6833 * length(time) )</span>

sum_st = sum(signal_data) - ( 0.6833 * length(time) );  <span class="comment">% Sum of s(t)</span>

<span class="comment">% We know that sum(s(t)) = sum(at) = a * sum(time) therefore:</span>
a = sum_st / sum(time);
signal_detrended = zeros(1,length(signal_data));        <span class="comment">% Preallocate space for speed</span>

<span class="comment">% For loop which removes linear bias from each data point</span>
<span class="keyword">for</span> i = 1:length(signal_data)
    signal_detrended(i) = signal_data(i) - (a * time(i));   <span class="comment">% We recover the original signal</span>
<span class="keyword">end</span>
</pre><h2 id="3">Grab the peak values and positions of the peaks</h2><pre class="codeinput"><span class="comment">% Construct a simple peak detection routine using a for loop. We do this by computing the</span>
<span class="comment">% gradients that come before and after a specific point.</span>
<span class="keyword">for</span> i = 2:length(signal_detrended)-1

    last_Slope = (  signal_detrended(i) - signal_detrended(i-1) ) / (0.1);    <span class="comment">% Keeps track of the previous gradient</span>
    next_Slope = (  signal_detrended(i+1) - signal_detrended(i) ) / (0.1);    <span class="comment">% Keeps track of the next gradient</span>

    <span class="keyword">if</span> (last_Slope &gt; 0) &amp;&amp; (next_Slope &lt; 0)     <span class="comment">% If the gradient goes from positive to negative</span>
        peaks = [peaks signal_detrended(i)];    <span class="comment">% Append the peak value to the peak array</span>
        timestamps = [timestamps time(i)];        <span class="comment">% Append the time to the locations array (where the peak occured)</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2 id="4">Prepare data structures prior to valid peak detection routine</h2><pre class="codeinput"><span class="comment">% Combine the peak and location arrays into a single data structure. This</span>
<span class="comment">% makes it easier to handle both sets of data at the same time.</span>
peaks_locs = [peaks' timestamps'];

<span class="comment">% Add a column of 'ones' to the data object. This column serves to 'flag'</span>
<span class="comment">% which peaks are valid (1) and which are invalid (0) All the peaks are</span>
<span class="comment">% initially flagged as valid.</span>
peaks_locs = [peaks_locs ones(length(peaks_locs),1)];

<span class="comment">% Sort the rows in ascending order based on the time stamps</span>
peaks_locs = sortrows(peaks_locs,2,{<span class="string">'ascend'</span>});

<span class="comment">% Sort the peaks in descending order seperately (stored in 'P')</span>
<span class="comment">% Grab the indices of these peaks (stored in 'I')</span>
[P, I] = maxk(peaks_locs(:,1),length(peaks_locs));
</pre><h2 id="5">Begin valid peak routine</h2><pre class="codeinput"><span class="comment">% For loop to interate over the peaks in descending order and marks them valid or invalid</span>
<span class="keyword">for</span> j = 1:length(peaks_locs)

    <span class="comment">% If statement to run the routine only when the peak is valid</span>
    <span class="keyword">if</span> peaks_locs(I(j),3) == 1

        current_maxPeak = P(j); <span class="comment">% Grab the current peak value</span>

        <span class="comment">% Find the index of the first peak that is within the last 5</span>
        <span class="comment">% seconds current peak.</span>
        index_minusFive = find(  (peaks_locs(:,2) &gt;= peaks_locs(I(j),2)-5) &amp; (peaks_locs(:,2) &lt; peaks_locs(I(j),2))  , 1, <span class="string">'first'</span>  );

        <span class="comment">% Find the index of the last peak that is within the next 5</span>
        <span class="comment">% seconds current peak.</span>
        index_plusFive  = find(  (peaks_locs(:,2) &lt;= peaks_locs(I(j),2)+5) &amp; (peaks_locs(:,2) &gt; peaks_locs(I(j),2))  , 1, <span class="string">'last'</span>   );

        <span class="comment">% ----------------------------- % % ----------------------------- %</span>
        <span class="keyword">if</span> ~isempty(index_minusFive)                    <span class="comment">% If the index is not empty</span>
            i = index_minusFive;

            <span class="comment">% While loop iterating over the peaks within the last 5 seconds of the current peak.</span>
            <span class="keyword">while</span> i &lt; I(j)
                <span class="keyword">if</span> peaks_locs(i,1) &gt; current_maxPeak/2  <span class="comment">% If the peak is smaller than current peak amplitude / 2</span>
                    peaks_locs(i,3) = 0;                <span class="comment">% Set it to invalid</span>
                <span class="keyword">end</span>
                i = i+1;
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% We follow the same logic for peaks that are within the next 5</span>
        <span class="comment">% seconds of the current peak</span>
        <span class="keyword">if</span> ~isempty(index_plusFive)
            i = index_plusFive;

            <span class="keyword">while</span> i &gt; I(j)
                <span class="keyword">if</span> peaks_locs(i,1) &gt; current_maxPeak/2
                    peaks_locs(i,3) = 0;
                <span class="keyword">end</span>
                i = i-1;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="comment">% ----------------------------- % % ----------------------------- %</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2 id="6">Determine the special peak</h2><pre class="codeinput">valid_rows = (peaks_locs(:,3) == 1);        <span class="comment">% Determine which rows have 'valid' peaks</span>
valid_peaks = peaks_locs(valid_rows,1:2);   <span class="comment">% Extract them into a seperate data structure</span>

special_peak = min(valid_peaks(:,1));            <span class="comment">% Grab the minimum valid peak value</span>
time_index = find(peaks == special_peak);        <span class="comment">% Find the index at which the special peak occurs in peaks</span>
sample_number = 1 + timestamps(time_index) * 10; <span class="comment">% Use the time index to calculate the sample number</span>
                                                 <span class="comment">% We add +1 to ensure it is 1-based&#8203;</span>
<span class="comment">% Display the values</span>
disp(<span class="string">'The special peak has a value of: '</span>)
disp(special_peak)
disp(<span class="string">'It is located at sample number: '</span>)
disp(sample_number)
</pre><pre class="codeoutput">The special peak has a value of: 
    0.4609

It is located at sample number: 
   992

</pre><h2 id="7">Plotting signals</h2><pre class="codeinput"><span class="comment">% Plot the biased signal vs. the detrended signal</span>
subplot(2,1,1)
plot(time,signal_data)
hold <span class="string">on</span>
plot(time,signal_detrended)
ylabel(<span class="string">'Signal Amplitude'</span>)
xlabel(<span class="string">'Time (seconds)'</span>)
title(<span class="string">'Biased Signal vs. Detrended Signal'</span>)
legend({<span class="string">'Biased Signal'</span>,<span class="string">'Detrended Signal'</span>})

<span class="comment">% Plot the detrended signal and where its 'valid' peaks are</span>
subplot(2,1,2)
plot(time,signal_detrended)
hold <span class="string">on</span>
scatter(valid_peaks(:,2),valid_peaks(:,1))
ylabel(<span class="string">'Signal Amplitude'</span>)
xlabel(<span class="string">'Time (seconds)'</span>)
title(<span class="string">'Detrended Signal with Identified Valid Peaks'</span>)

<span class="comment">% ======================================================================== %</span>
</pre><img vspace="5" hspace="5" src="tatch_exercise_01.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Import the relevant signal data
% I converted the csv to a text file prior to using it because it was
% easier to import. 

signal_data_file = 'Signal.txt';                       % Grab the file name 
delimiter = ',';                                       % Set delimiter as a comma since data is seperated via commas
signal_data = importdata(signal_data_file,delimiter);  % Import the data 
time = 0:0.1:180.0;                                    % Create a time vector based on the sampling rate. (10Hz = 0.1s spanning 1801 points)      

% Initialize two empty arrays which will dynamically grow as we find peaks
peaks = [];             % Will hold the peak values 
timestamps = [];        % Will hold the time stamps at which the peaks are found 

signal_mean_value = 0.6833; % The expected true signal mean value 

%% Detrend the signal to remove the linear bias 

% We know that y(t) = s(t) + at. We also know that sum(s(t)) / length(t) = 0.6833
% We can use this information to derive the linear bias 'a': 
% sum( y(t) - s(t) ) / length(time)  =  0.6833
% => sum(y(t)) - sum(s(t)) = 0.6833 * length(time)  
% => sum(s(t)) = sum(y(t)) - ( 0.6833 * length(time) ) 

sum_st = sum(signal_data) - ( 0.6833 * length(time) );  % Sum of s(t)

% We know that sum(s(t)) = sum(at) = a * sum(time) therefore: 
a = sum_st / sum(time); 
signal_detrended = zeros(1,length(signal_data));        % Preallocate space for speed

% For loop which removes linear bias from each data point 
for i = 1:length(signal_data)
    signal_detrended(i) = signal_data(i) - (a * time(i));   % We recover the original signal 
end

%% Grab the peak values and positions of the peaks

% Construct a simple peak detection routine using a for loop. We do this by computing the
% gradients that come before and after a specific point. 
for i = 2:length(signal_detrended)-1
    
    last_Slope = (  signal_detrended(i) - signal_detrended(i-1) ) / (0.1);    % Keeps track of the previous gradient  
    next_Slope = (  signal_detrended(i+1) - signal_detrended(i) ) / (0.1);    % Keeps track of the next gradient
    
    if (last_Slope > 0) && (next_Slope < 0)     % If the gradient goes from positive to negative
        peaks = [peaks signal_detrended(i)];    % Append the peak value to the peak array
        timestamps = [timestamps time(i)];        % Append the time to the locations array (where the peak occured)
    end
end

%% Prepare data structures prior to valid peak detection routine

% Combine the peak and location arrays into a single data structure. This
% makes it easier to handle both sets of data at the same time. 
peaks_locs = [peaks' timestamps'];

% Add a column of 'ones' to the data object. This column serves to 'flag'
% which peaks are valid (1) and which are invalid (0) All the peaks are
% initially flagged as valid. 
peaks_locs = [peaks_locs ones(length(peaks_locs),1)]; 

% Sort the rows in ascending order based on the time stamps
peaks_locs = sortrows(peaks_locs,2,{'ascend'});

% Sort the peaks in descending order seperately (stored in 'P')
% Grab the indices of these peaks (stored in 'I')
[P, I] = maxk(peaks_locs(:,1),length(peaks_locs));

%% Begin valid peak routine

% For loop to interate over the peaks in descending order and marks them valid or invalid
for j = 1:length(peaks_locs)
    
    % If statement to run the routine only when the peak is valid
    if peaks_locs(I(j),3) == 1  
    
        current_maxPeak = P(j); % Grab the current peak value 
        
        % Find the index of the first peak that is within the last 5
        % seconds current peak.
        index_minusFive = find(  (peaks_locs(:,2) >= peaks_locs(I(j),2)-5) & (peaks_locs(:,2) < peaks_locs(I(j),2))  , 1, 'first'  );
        
        % Find the index of the last peak that is within the next 5
        % seconds current peak.
        index_plusFive  = find(  (peaks_locs(:,2) <= peaks_locs(I(j),2)+5) & (peaks_locs(:,2) > peaks_locs(I(j),2))  , 1, 'last'   );
        
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- % % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- % 
        if ~isempty(index_minusFive)                    % If the index is not empty 
            i = index_minusFive;        

            % While loop iterating over the peaks within the last 5 seconds of the current peak. 
            while i < I(j)                        
                if peaks_locs(i,1) > current_maxPeak/2  % If the peak is smaller than current peak amplitude / 2
                    peaks_locs(i,3) = 0;                % Set it to invalid 
                end
                i = i+1;
            end
        end
        
        % We follow the same logic for peaks that are within the next 5
        % seconds of the current peak
        if ~isempty(index_plusFive)
            i = index_plusFive;

            while i > I(j)
                if peaks_locs(i,1) > current_maxPeak/2
                    peaks_locs(i,3) = 0;
                end
                i = i-1;
            end
        end
        % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- % % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- % 
    end
end

%% Determine the special peak

valid_rows = (peaks_locs(:,3) == 1);        % Determine which rows have 'valid' peaks
valid_peaks = peaks_locs(valid_rows,1:2);   % Extract them into a seperate data structure

special_peak = min(valid_peaks(:,1));            % Grab the minimum valid peak value
time_index = find(peaks == special_peak);        % Find the index at which the special peak occurs in peaks
sample_number = 1 + timestamps(time_index) * 10; % Use the time index to calculate the sample number
                                                 % We add +1 to ensure it is 1-based​     
% Display the values
disp('The special peak has a value of: ')             
disp(special_peak)
disp('It is located at sample number: ')
disp(sample_number)

%% Plotting signals 

% Plot the biased signal vs. the detrended signal
subplot(2,1,1)
plot(time,signal_data)
hold on
plot(time,signal_detrended)
ylabel('Signal Amplitude')
xlabel('Time (seconds)')
title('Biased Signal vs. Detrended Signal')
legend({'Biased Signal','Detrended Signal'})

% Plot the detrended signal and where its 'valid' peaks are
subplot(2,1,2)
plot(time,signal_detrended)
hold on
scatter(valid_peaks(:,2),valid_peaks(:,1))
ylabel('Signal Amplitude')
xlabel('Time (seconds)')
title('Detrended Signal with Identified Valid Peaks')

% ======================================================================== %
##### SOURCE END #####
--></body></html>